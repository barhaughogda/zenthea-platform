# Phase G.0 – Persistence Architecture Lock (Raw SQL + Migrations)

## Status
LOCKED

## Classification
DESIGN-ONLY

## Authority Declaration
**THIS DOCUMENT DOES NOT AUTHORIZE EXECUTION.**
This is a design-only lock. No code may be written, no databases may be provisioned, and no migrations may be executed based on this document. Authorization for implementation will be granted in subsequent G.x phases.

## Effective Date
2026-01-19

## Scope
This document locks the **Persistence Architecture** for the entire Zenthea EHR platform. It defines the immutable rules for how data moves between the application memory and durable storage.

---

## 1. Architectural Philosophy: Persistence as an Adapter
Persistence is an external concern. It is an **adapter**, not a collaborator.
- The **EHR Core (`packages/ehr-core`)** MUST remain strictly persistence-agnostic.
- Domain models MUST NOT contain database annotations, decorators, or storage-specific logic.
- The domain layer defines the interface (Repository Pattern); the persistence layer implements it.

---

## 2. Technical Mandates

### 2.1 Raw SQL Only
- All database interactions MUST use **Raw SQL**.
- No Object-Relational Mappers (ORMs) are permitted (e.g., TypeORM, Prisma, Sequelize are FORBIDDEN).
- Query builders are permitted ONLY if they generate transparent, auditable SQL and do not hide the underlying schema.

### 2.2 Explicit Migrations
- Schema changes MUST be handled through **explicit, versioned migration files**.
- All migrations MUST be written in Raw SQL.
- "Auto-sync" or schema generation from code is STRICTLY FORBIDDEN.
- Production migrations MUST be reviewed and locked before execution.

### 2.3 No Runtime Migrations
- Application startup MUST NOT trigger database migrations.
- Migrations are a deployment-time concern, managed by the platform infrastructure, never the application process.

### 2.4 Transaction Semantics
- Transactions MUST be **explicitly initiated and committed/rolled back**.
- Transaction boundaries MUST be fail-closed.
- No implicit or "magic" transaction management.

---

## 3. Prohibited Practices (LOCKED OUT)

### 3.1 No Business Logic in Database
- No stored procedures, no user-defined functions (UDFs).
- No triggers containing business logic.
- Triggers are permitted ONLY for audit logging or basic timestamping (e.g., `updated_at`).

### 3.2 No AI-Generated SQL
- SQL queries MUST NOT be generated by AI models at runtime.
- SQL queries used in the application MUST be static and authored/reviewed by human engineers.

### 3.3 No Event Sourcing
- Event sourcing as a primary persistence mechanism is FORBIDDEN.
- The system of record MUST be a normalized relational state.

### 3.4 No Background Jobs in DB
- The database MUST NOT be used as a task queue or background job coordinator via triggers or specialized tables.

---

## 4. Future Sequencing (G.1–G.4)
The following phases are defined for planning purposes but remain **UNAUTHORIZED** for execution:

- **Phase G.1**: Schema definition for Patient and Practitioner domains.
- **Phase G.2**: Repository implementation for Patient and Practitioner.
- **Phase G.3**: Schema and Repository for Encounter and Clinical Note.
- **Phase G.4**: Transactional integration and audit log persistence.

---

## 5. Compliance & Enforcement
- Any attempt to introduce an ORM is a violation of this lock.
- Any attempt to bypass explicit migrations is a violation of this lock.
- Any leak of database concerns into `packages/ehr-core` is a violation of this lock.

---

## 6. Final Declaration
Phase G.0 establishes a "No-Magic" persistence layer. We trade developer convenience for absolute predictability, auditability, and safety. The database is a passive container for state, managed by explicit human intent.
